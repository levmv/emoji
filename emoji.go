package emoji

var indexTable = [704]byte{
	0x0c2: 0x02, 0x0c3: 0x02, 0x0c4: 0x02, 0x0c5: 0x02, 0x0c6: 0x02, 0x0c7: 0x02,
	0x0c8: 0x02, 0x0c9: 0x02, 0x0ca: 0x02, 0x0cb: 0x02, 0x0cc: 0x02, 0x0cd: 0x02,
	0x0ce: 0x02, 0x0cf: 0x02, 0x0d0: 0x02, 0x0d1: 0x02, 0x0d2: 0x02, 0x0d3: 0x02,
	0x0d4: 0x02, 0x0d5: 0x02, 0x0d6: 0x02, 0x0d7: 0x02, 0x0d8: 0x02, 0x0d9: 0x02,
	0x0da: 0x02, 0x0db: 0x02, 0x0dc: 0x02, 0x0dd: 0x02, 0x0de: 0x02, 0x0df: 0x02,
	0x0e0: 0x03, 0x0e1: 0x03, 0x0e2: 0x13, 0x0e3: 0x1b, 0x0e4: 0x03, 0x0e5: 0x03,
	0x0e6: 0x03, 0x0e7: 0x03, 0x0e8: 0x03, 0x0e9: 0x03, 0x0ea: 0x03, 0x0eb: 0x03,
	0x0ec: 0x03, 0x0ed: 0x03, 0x0ee: 0x03, 0x0ef: 0x23, 0x0f0: 0x34, 0x0f1: 0x04,
	0x0f2: 0x04, 0x0f3: 0x44, 0x0f4: 0x04, 0x100: 0x01, 0x101: 0x02, 0x103: 0x03,
	0x104: 0x04, 0x106: 0x05, 0x10c: 0x06, 0x10f: 0x07, 0x113: 0x08, 0x116: 0x09,
	0x117: 0x0a, 0x118: 0x0b, 0x119: 0x0c, 0x11a: 0x0d, 0x11b: 0x0e, 0x11c: 0x0f,
	0x11d: 0x10, 0x11e: 0x11, 0x124: 0x12, 0x12c: 0x13, 0x12d: 0x14, 0x140: 0x15,
	0x14a: 0x16, 0x1b8: 0x17, 0x1c0: 0x18, 0x1c3: 0x19, 0x1c5: 0x1a, 0x1c6: 0x1b,
	0x1c7: 0x1c, 0x1c8: 0x1d, 0x1c9: 0x1e, 0x1cc: 0x1f, 0x1cd: 0x20, 0x1ce: 0x21,
	0x1cf: 0x22, 0x1d0: 0x23, 0x1d1: 0x24, 0x1d2: 0x25, 0x1d3: 0x26, 0x1d4: 0x27,
	0x1d5: 0x28, 0x1d6: 0x29, 0x1d7: 0x2a, 0x1d8: 0x2b, 0x1d9: 0x2c, 0x1da: 0x2d,
	0x1db: 0x2e, 0x1df: 0x2f, 0x1e4: 0x30, 0x1e5: 0x31, 0x1e6: 0x32, 0x1e7: 0x33,
	0x1e9: 0x34, 0x1ea: 0x35, 0x1eb: 0x36, 0x21f: 0x05, 0x241: 0x37, 0x2a0: 0x07,
}
var valuesTable = [56]uint64{
	0x0000000000000000, 0x1000000000002000, 0x0000000000000200, 0x0000000800000000,
	0x0200000000000000, 0x0000060003f00000, 0x000001000c000000, 0x070ffe0000008000,
	0x0000000000000004, 0x00400c0000000000, 0x7800000000000001, 0x0700c44d2132401f,
	0xc8000169800fff05, 0x60030c831afc0000, 0x27bf0600001ac130, 0x001801022054bf24,
	0x0000001800b85090, 0x8001000200e00000, 0x0030000000000000, 0x00000000180000e0,
	0x0000000000210000, 0x2001000000000000, 0x0000000002800000, 0x0000000000008000,
	0x0000000000000010, 0x0000000000008000, 0xc003000000000000, 0x0000000007fe4000,
	0xffffffc000000000, 0x07fc800004000006, 0x0000000000030000, 0xfffffff3ffffffff,
	0xffffffffffffffff, 0xffffffffcecfffff, 0xffb9ffffffffffff, 0xffffffffffffffff,
	0xffffffffffffffff, 0xffffffffffffffff, 0xbfffffffffffffff, 0x3fffffffffffffff,
	0x07f980ffffff7e00, 0x1006013000613c80, 0xfc08810a700e001c, 0xffffffffffffffff,
	0x000000000000ffff, 0xffffffffffffffff, 0x1ff91a3ff0e7f83f, 0x00010fff00000000,
	0xf7fffffffffff000, 0xffffffffffffffbf, 0xffffffffffffffff, 0xffffffffffffffff,
	0x1fff000000000000, 0xbfffffffffff01ff, 0x01ff01ff0fffc03f, 0x809850ac00000000,
}

func Remove(s []byte) []byte {
	if len(s) < 2 {
		return s
	}

	var (
		sz int
		i  int
		i2 int
	)

	if i, sz = find(s); sz == 0 {
		return s
	}

	buf := make([]byte, len(s)-sz)

	copy(buf, s[:i])
	destI := i
	i += sz
	for i < len(s) { // TODO: rewrite that
		i2, sz = find(s[i:])
		if sz == 0 {
			copy(buf[destI:], s[i:])
			destI += len(s) - i
			break
		}
		copy(buf[destI:], s[i:i+i2])
		destI += i2
		i += i2 + sz
	}

	return buf[:destI]
}

// find returns position and size of first found emoji in string
// more specific, size not of single emoji, but length of a continuous sequence of any emoji runes
func find(s []byte) (offset, size int) {
	var (
		i      int
		streak int
	)

	for i = 0; i < len(s)-1; {
		sz, found := lookup(s[i:])
		if found {
			if streak == 0 {
				offset = i
			}
			streak++
			size += sz

			// special case of keycap emoji
			if isKeycapSymbol(s, i) {
				if streak == 1 && isNum(s, i) {
					offset--
					size++
				} else if streak == 2 && isNum(s, i-sz) {
					offset--
					size++
				}
			}
		} else if streak > 0 {
			break
		}
		i += sz
	}

	return offset, size
}

func isKeycapSymbol(s []byte, i int) bool {
	return s[i] == 0xe2 && s[i+1] == 0x83 && s[i+2] == 0xA3
}

func isNum(s []byte, i int) bool {
	if i == 0 {
		return false
	}
	return (0x23 <= s[i-1] && s[i-1] <= 0x39)
}

// lookup return byte size of rune and if it's emoji rune
func lookup(s []byte) (size int, found bool) {
	s0 := s[0]
	// we use 0xC0 instead 0x80 to free for use two index blocks. 80-C0 range in illegal in utf8
	if s0 < 0xC0 {
		return 1, false
	}
	i := indexTable[s0]

	size = int(i & 7)
	i >>= 3

	if i == 0 { // unnecessary, but a bit faster when we have a lot 2-3 bytes input
		return size, false
	}

	if s0 < 0xE0 { // 2-byte UTF-8
		return size, lookupValue(i, s[1])
	}

	i = indexTable[uint32(i)<<6+uint32(s[1])]
	if s0 < 0xF0 { // 3-byte UTF-8
		return 3, lookupValue(i, s[2])
	}

	i = indexTable[uint32(i)<<6+uint32(s[2])]
	return 4, lookupValue(i, s[3])
}

func lookupValue(i, v byte) bool {
	return (valuesTable[i] & uint64(1<<(v-0x80))) != 0
}
